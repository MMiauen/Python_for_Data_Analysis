# 第十一章 时间序列
## 11.1 日期和时间数据的类型及工具
datetime、time、calendar模块是处理时间数据的主要内容。其中，使用最广泛的是datetime.datetime类型。

datetime存储的时间能细化到微妙：


```python
from datetime import datetime
now=datetime.now()
now
```




    datetime.datetime(2019, 11, 13, 19, 27, 5, 816361)




```python
now.year,now.month,now.day
```




    (2019, 11, 13)



timedelta表示两个datetime对象的时间差。timedelta(x,y)其中x表示天数，y表示秒数：


```python
datetime(1995,8,27)-datetime(1995,11,26,23,15,8)
```




    datetime.timedelta(days=-92, seconds=2692)



### 11.1.1 字符串与datetime互相转换
对于一个已知的datetime对象，你可以使用str或者指定格式的strftime对其进行格式化：


```python
MarryDay=datetime(2018,8,8,8,8)
```


```python
str(MarryDay)
```




    '2018-08-08 08:08:00'




```python
MarryDay.strftime('%F')  ## %F是%Y-%m-%d的简写
```




    '2018-08-08'



同理，已知一个字符串时，你也可以将其转换为日期：(1)strptime  (2)parser.parse


```python
value='2011-01-03'
datetime.strptime(value,'%Y-%m-%d')
```




    datetime.datetime(2011, 1, 3, 0, 0)



datetime.strptime是在已知格式下转化日期的好方法，但是每次都编写一个日期格式比较麻烦。简便方法是使用第三方dateutil包中的parser.parse方法（这个包已经在pandas中了）


```python
from dateutil.parser import parse
parse('2011-01-03')
```




    datetime.datetime(2011, 1, 3, 0, 0)



datetime还可以解析大部分人类可理解的日期表示：


```python
parse('Jan 31, 1998 10:45 PM')
```




    datetime.datetime(1998, 1, 31, 22, 45)



国际场合下，日期出现在月份之前很常见，为了避免混淆，可以传递dayfirst=True来表明这种情况：


```python
parse('1/8/1995')  #未声明时
```




    datetime.datetime(1995, 1, 8, 0, 0)




```python
parse('1/8/1995',dayfirst=True)  #声明后
```




    datetime.datetime(1995, 8, 1, 0, 0)



dateutil.parser是一个有用但并不完美的工具，有时他会将一些字符串识别为错误的日期。使用时需非常小心。

## 11.2 时间序列基础


```python
import pandas as pd
import numpy as np
from datetime import datetime
dates=[datetime(2011,1,1),datetime(2012,1,1),datetime(2013,1,1)]
ts=pd.Series(np.random.randn(3),index=dates)
ts
```




    2011-01-01   -1.764979
    2012-01-01   -0.214107
    2013-01-01    0.270312
    dtype: float64




```python
### ts[::2]会将ts中每隔一个的元素选择出
ts[::2]
```




    2011-01-01   -1.764979
    2013-01-01    0.270312
    dtype: float64



### 11.2.1 索引、选择、子集
从时间序列中基于标签进行索引时，其行为和其它的pandas.Series类似：


```python
ts[1]
```




    -0.2141070825192476



为了简便，还可以直接传递能解释为日期的字符串进行索引：


```python
ts['20130101']
```




    0.2703115980869953



同理，对于较长的时间序列，可以通过传递一个年份或月份轻松的对其进行索引：


```python
long_ts=pd.Series(np.random.randn(1000),index=pd.date_range('19951126',periods=1000))
###传递年份
long_ts['1996']
```




    1996-01-01   -0.047815
    1996-01-02   -0.522872
    1996-01-03    0.038374
    1996-01-04    0.048923
    1996-01-05   -0.555643
                    ...   
    1996-12-27    1.361538
    1996-12-28    0.654490
    1996-12-29   -0.878017
    1996-12-30    1.469675
    1996-12-31   -1.914027
    Freq: D, Length: 366, dtype: float64




```python
### 传递年月
long_ts['1996-11']
```




    1996-11-01    1.667685
    1996-11-02    1.489176
    1996-11-03    1.528001
    1996-11-04   -2.454080
    1996-11-05    0.218448
    1996-11-06    0.507521
    1996-11-07    0.967550
    1996-11-08    1.379875
    1996-11-09    1.393590
    1996-11-10   -1.453596
    1996-11-11    0.461501
    1996-11-12    1.916440
    1996-11-13   -1.054503
    1996-11-14    1.768789
    1996-11-15   -0.072850
    1996-11-16    0.745754
    1996-11-17   -1.639385
    1996-11-18    0.962356
    1996-11-19    0.577135
    1996-11-20    0.015039
    1996-11-21   -0.069068
    1996-11-22    0.609213
    1996-11-23    0.223464
    1996-11-24   -0.155493
    1996-11-25    0.716439
    1996-11-26    0.504748
    1996-11-27    0.348685
    1996-11-28    0.360164
    1996-11-29    1.791424
    1996-11-30    0.630464
    Freq: D, dtype: float64




```python
### 查询时不一定只能输入序列中存在的时间，也可以使用不包含在序列中的时间戳进行切片
long_ts['1995-08-27':'1995-11-30']
```




    1995-11-26   -1.429734
    1995-11-27    0.450747
    1995-11-28    1.498385
    1995-11-29   -0.932734
    1995-11-30    1.413754
    Freq: D, dtype: float64




```python
### 上述例子还有一个等价方法 truncate,自己设定一个截止日期after，查询操作将从序列开头查询至after
long_ts.truncate(after='1995-11-28')
```




    1995-11-26   -1.429734
    1995-11-27    0.450747
    1995-11-28    1.498385
    Freq: D, dtype: float64



### 11.2.2 含有重复索引的时间序列
某些时候，可能有多个观察值落在特定的时间戳上，例如：


```python
dates=pd.DatetimeIndex(['1995-10-23','1995-11-26','1995-11-26','1995-08-27'])
ts1=pd.Series([11,23,18,9],index=dates)
ts1
```




    1995-10-23    11
    1995-11-26    23
    1995-11-26    18
    1995-08-27     9
    dtype: int64




```python
### 检查序列的索引是否唯一
ts1.index.is_unique
```




    False




```python
### 当你查询含有重复时间戳的索引时，会出现多个结果：
ts1['1995-11-26']
```




    1995-11-26    23
    1995-11-26    18
    dtype: int64




```python
### 如果你想把含有多个时间戳的时间数据聚合起来，比如将本例中1995-11-26日的两个数据合并为一组，
### 可以使用之前所学的groupby方法，并传递level=0
grouped=ts1.groupby(level=0)
grouped.count()
```




    1995-08-27    1
    1995-10-23    1
    1995-11-26    2
    dtype: int64



## 11.3 日期范围、频率和移位
Pandas的通用时间序列是不规则的，这已经能满足大多数应用场景。但是，若想处理固定频率的场景，例如每日、每月、每15分钟，这就意味着我们可能需要向时间序列中引入缺失值。

幸运的是，Pandas功能强大，拥有一整套标准工具用于计算轴向重采样、推断频率以及生成固定频率的数据范围。
### 11.3.1 生成日期范围
pandas.date_range是用于根据特定频率生成指定长度的DatetimeIndex

默认情况下，在特定范围内，date_range生成的是范围内每日时间戳；

但是如果你只传递一个起始日期或截止日期，那么还需要传递一个用于生成范围（periods参数）的数字，即数字是几就生成几个时间戳


```python
pd.date_range('1995-11-26','1995-11-30')
```




    DatetimeIndex(['1995-11-26', '1995-11-27', '1995-11-28', '1995-11-29',
                   '1995-11-30'],
                  dtype='datetime64[ns]', freq='D')




```python
### 即给定范围，又指定生成个数时，结果是按长度比例生成的时间戳
pd.date_range('1995-11-26','1995-12-30',periods=3)
```




    DatetimeIndex(['1995-11-26', '1995-12-13', '1995-12-30'], dtype='datetime64[ns]', freq=None)




```python
pd.date_range('1995-11-26',periods=5)
```




    DatetimeIndex(['1995-11-26', '1995-11-27', '1995-11-28', '1995-11-29',
                   '1995-11-30'],
                  dtype='datetime64[ns]', freq='D')




```python
pd.date_range(end='1995-11-26',periods=5)
```




    DatetimeIndex(['1995-11-22', '1995-11-23', '1995-11-24', '1995-11-25',
                   '1995-11-26'],
                  dtype='datetime64[ns]', freq='D')



除了传递起止时间、生成个数之外。你还可以通过传递频率参数freq，来决定生成时间序列的频率。例如：


```python
### ‘M’代表 MonthEnd 是日历上每个月的月底
pd.date_range('2019-1-1','2019-12-31',freq='M')
```




    DatetimeIndex(['2019-01-31', '2019-02-28', '2019-03-31', '2019-04-30',
                   '2019-05-31', '2019-06-30', '2019-07-31', '2019-08-31',
                   '2019-09-30', '2019-10-31', '2019-11-30', '2019-12-31'],
                  dtype='datetime64[ns]', freq='M')




```python
### 'B' 代表 BussinessDay  是工作日的每天
pd.date_range('1995-11-26','1995-12-10',freq='B')
```




    DatetimeIndex(['1995-11-27', '1995-11-28', '1995-11-29', '1995-11-30',
                   '1995-12-01', '1995-12-04', '1995-12-05', '1995-12-06',
                   '1995-12-07', '1995-12-08'],
                  dtype='datetime64[ns]', freq='B')



有些时候，起止日期会精确到小时分钟，但是我们只想要日期，这时可以使用normalize对其进行标准化：


```python
### 标准化前
pd.date_range('1995-11-26 23:56',periods=3)
```




    DatetimeIndex(['1995-11-26 23:56:00', '1995-11-27 23:56:00',
                   '1995-11-28 23:56:00'],
                  dtype='datetime64[ns]', freq='D')




```python
### 标准化后
pd.date_range('1995-11-26 23:56',periods=3,normalize=True)
```




    DatetimeIndex(['1995-11-26', '1995-11-27', '1995-11-28'], dtype='datetime64[ns]', freq='D')



### 11.3.2 频率和日期偏置
Pandas中的频率是由基础频率和倍数组成的。例如：


```python
pd.date_range('1995-11-26','1995-11-27',freq='5h')
```




    DatetimeIndex(['1995-11-26 00:00:00', '1995-11-26 05:00:00',
                   '1995-11-26 10:00:00', '1995-11-26 15:00:00',
                   '1995-11-26 20:00:00'],
                  dtype='datetime64[ns]', freq='5H')




```python
pd.date_range('1995-11-26','1995-11-27',freq='6h30min')
```




    DatetimeIndex(['1995-11-26 00:00:00', '1995-11-26 06:30:00',
                   '1995-11-26 13:00:00', '1995-11-26 19:30:00'],
                  dtype='datetime64[ns]', freq='390T')




```python
pd.date_range('1995-11-26','1995-12-1',freq='2d3h')
```




    DatetimeIndex(['1995-11-26 00:00:00', '1995-11-28 03:00:00',
                   '1995-11-30 06:00:00'],
                  dtype='datetime64[ns]', freq='51H')



【月中某星期的日期】(week of month)是一个非常有用的频率。例如你可以获取每月第三个星期一这样的日期：


```python
pd.date_range('2019-1-1','2019-12-31',freq='WOM-3MON')
```




    DatetimeIndex(['2019-01-21', '2019-02-18', '2019-03-18', '2019-04-15',
                   '2019-05-20', '2019-06-17', '2019-07-15', '2019-08-19',
                   '2019-09-16', '2019-10-21', '2019-11-18', '2019-12-16'],
                  dtype='datetime64[ns]', freq='WOM-3MON')



### 13.3.3 移位（前向和后向）日期
“移位”是指将数据向前或向后移动，而不改变索引。Series和DataFrame中的shift方法即可实现移位：


```python
ts=pd.Series([1,3,5,7],index=pd.date_range('1995-11-26',periods=4,freq='M'))
ts
```




    1995-11-30    1
    1995-12-31    3
    1996-01-31    5
    1996-02-29    7
    Freq: M, dtype: int64




```python
## 前移2个
ts.shift(-2)
```




    1995-11-30    5.0
    1995-12-31    7.0
    1996-01-31    NaN
    1996-02-29    NaN
    Freq: M, dtype: float64




```python
## 后移两个
ts.shift(2)
```




    1995-11-30    NaN
    1995-12-31    NaN
    1996-01-31    1.0
    1996-02-29    3.0
    Freq: M, dtype: float64



可以看出，简单的shift移动后，时间序列的起始位或结束位引入了缺失值，一些数据被丢弃了

实际上，在频率已知的情况下，我们可以将频率也传递给shift来推移时间戳，而不是简单的数据：


```python
ts.shift(2,freq='M')
```




    1996-01-31    1
    1996-02-29    3
    1996-03-31    5
    1996-04-30    7
    Freq: M, dtype: int64



由上可以看出，原本空缺值的索引不见了，而是向着移位方向按给定频率 生成新的索引，充分利用了原始数据。

#### 11.3.3.1 使用偏置进行移位日期


```python
from pandas.tseries.offsets import Day,MonthEnd
now=datetime(2019,11,15)
```


```python
now+3*Day()
```




    Timestamp('2019-11-18 00:00:00')




```python
now+MonthEnd()   # 日期将滚动到本月的最后一天
```




    Timestamp('2019-11-30 00:00:00')




```python
now+MonthEnd(2)   # 日期将滚动到下个月的最后一天
```




    Timestamp('2019-12-31 00:00:00')



锚定偏置可以使用rollforward和rollback分别显式的向日期前后“滚动”


```python
### 首先定义偏置类型,例如每月最后一天
offset=MonthEnd()
### 对指定时间now(2019-11-15)进行向前滚动
offset.rollforward(now)
```




    Timestamp('2019-11-30 00:00:00')



## 11.4 时区处理
好像不太常用，用到的时候再学 P320

## 11.5 时间区间和区间算术
时间区间表示的是时间范围，pandas中Period类表示的正是这种数据类型


```python
p=pd.Period(2019,'A-DEC')
p
```




    Period('2019', 'A-DEC')



上述period对象表示的是从2019年1月1日到2019年12月31日的时间段

使用period_range函数可以构造规则区间序列：


```python
rng=pd.period_range('2019-1-1','2019-6-30',freq='M')
rng
```




    PeriodIndex(['2019-01', '2019-02', '2019-03', '2019-04', '2019-05', '2019-06'], dtype='period[M]', freq='M')


